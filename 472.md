### Trie Approach 
```java
class Solution {
    private Set<String> result;

    public List<String> findAllConcatenatedWordsInADict(String[] words) {
        result = new HashSet<>();
        Trie trie = new Trie();

        for (String word : words) {
            if (word.length() != 0) trie.insert(word);
        }

        for (String word : words) {
            if (word.length() != 0) trie.find(word, word, 0, result);
        }

        return new ArrayList<>(result);
    }

    static class Node {
        Node[] chars = new Node[26];
        boolean isEnd;

        public boolean contains(char ch) {
            return chars[ch - 'a'] != null;
        }
    }

    static class Trie {
        Node root;

        Trie() {
            root = new Node();
        }

        public void insert(String key) {
            Node temp = root;
            for (char ch : key.toCharArray()) {
                if (!temp.contains(ch)) temp.chars[ch - 'a'] = new Node();
                temp = temp.chars[ch - 'a'];
            }
            temp.isEnd = true;
        }

        public void find(String word, String original, int split, Set<String> result) {
            if (word.length() == 0 && split >= 2) {
                result.add(original);
                return;
            }

            Node temp = root;
            for (int i = 0; i < word.length(); i++) {
                if (!temp.contains(word.charAt(i))) return;
                temp = temp.chars[word.charAt(i) - 'a'];
                if (temp.isEnd) find(word.substring(i + 1), original, split + 1, result);
            }
        }
    }
}
```
